{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"What is NextCV?","text":"<p>Fast computer vision in Python. C++ performance with Python simplicity.</p> <p>NextCV is like OpenCV but with modern tooling. It's a minimal, experimental CV library built with:</p> <ul> <li>C++ speed + Python ease via pybind11</li> <li>Modern tooling (uv, scikit-build-core)</li> <li>Cross-platform (macOS, Linux)</li> <li>CI/CD (GitHub Actions)</li> </ul>"},{"location":"#-quick-start","title":"\ud83d\ude80 Quick Start","text":"<pre><code># Using uv (recommended)\nuv add git+https://github.com/kevinconka/nextcv.git\n\n# Or with pip\npip install git+https://github.com/kevinconka/nextcv.git\n</code></pre> <pre><code>import nextcv as cvx\n\n# C++ wrapped functions (high performance)\nprint(cvx.hello_cpp())  # \"Hello from NextCV (C++)\"\n\n# Image processing\nimport numpy as np\nimage = np.random.randint(0, 255, (100, 100, 3), dtype=np.uint8)\ninverted = cvx.image.invert(image)\n\n# Post-processing\nboxes = np.array([[10, 10, 50, 50], [20, 20, 60, 60]], dtype=np.float32)\nscores = np.array([0.9, 0.8], dtype=np.float32)\nfiltered_boxes = cvx.postprocessing.nms_cpp(boxes, scores, 0.5)\n</code></pre>"},{"location":"#-buy-me-a-coffee","title":"\u2615\ufe0f Buy Me a Coffee","text":"<p>Primpting AI agents is hard! Coffees are needed when AI agents derail so much I actually have to write code.</p> <p></p>"},{"location":"cli/","title":"CLI Reference","text":"<p>NextCV currently focuses on Python API usage. CLI tools will be added in future releases.</p> <p>For now, check out the API Reference for all available functionality.</p>"},{"location":"examples/","title":"NextCV Examples","text":"<p>Quick examples showing how to use NextCV for computer vision tasks.</p>"},{"location":"examples/#-core-module","title":"\ud83d\udce6 Core Module","text":"<pre><code>import nextcv as cvx\n\n# Hello functions\nprint(cvx.core.hello_cpp())     # \"Hello from C++!\"\nprint(cvx.core.hello_python())  # \"Hello from Python!\"\n</code></pre>"},{"location":"examples/#-image-module","title":"\ud83d\uddbc\ufe0f Image Module","text":"<pre><code>import numpy as np\nimport nextcv as cvx\n\n# Image inversion\nimage = np.random.randint(0, 255, (100, 100, 3), dtype=np.uint8)\ninverted = cvx.image.invert(image)\nprint(f\"Shape: {image.shape} -&gt; {inverted.shape}\")\n</code></pre>"},{"location":"examples/#-postprocessing-module","title":"\ud83c\udfaf Postprocessing Module","text":"<pre><code>import numpy as np\nimport nextcv as cvx\n\n# Non-Maximum Suppression\nboxes = np.array([[10, 10, 50, 50], [20, 20, 60, 60]], dtype=np.float32)\nscores = np.array([0.9, 0.8], dtype=np.float32)\n\nfiltered = cvx.postprocessing.nms(boxes, scores, threshold=0.5)\nprint(f\"Kept {len(filtered)} out of {len(boxes)} boxes\")\n</code></pre>   **Ready to build something amazing?** \ud83d\ude80  [Get Started](getting-started.md) \u2022 [View API](reference/) \u2022 [Contribute](pybind11-guide.md)"},{"location":"pybind11/","title":"PyBind11 Development Guide","text":"<p>Hey there! \ud83d\udc4b Welcome to the NextCV development guide where we're going to make your Python code absolutely blazing fast when it actually matters. Think of this as your roadmap to building computer vision tools that are both easy to use AND lightning quick.</p>"},{"location":"pybind11/#-the-nextcv-philosophy-smart-performance-not-just-fast-performance","title":"\ud83c\udfaf The NextCV Philosophy: Smart Performance, Not Just Fast Performance","text":"<p>Our Approach</p> <p>Here's the thing - we're not trying to rewrite the entire Python ecosystem in C++. That would be like using a Formula 1 car to go to the grocery store.</p> <p>Instead, we follow a much smarter approach:</p> Python for Prototyping C++ for Performance C++ Standalone Ready Best of Both  <ul> <li>Quick iteration: Perfect for rapid development and testing</li> <li>Familiar ecosystem: Leverage existing Python libraries</li> <li>Easy debugging: Use standard Python tools</li> <li>Great for MVPs: Get features working fast</li> </ul> <ul> <li>Optimized code: When Python hits performance limits</li> <li>Memory control: Fine-grained memory management</li> <li>SIMD/Threading: Hardware-level optimizations</li> <li>Real bottlenecks: Solve actual performance issues</li> </ul> <ul> <li>Header-only: Easy to include in C++ projects</li> <li>No Python deps: Works without Python runtime</li> <li>Clean APIs: Well-documented C++ interfaces</li> <li>Modern C++: Using C++17 features</li> </ul> <ul> <li>Gradual optimization: Start Python, optimize later</li> <li>Mixed usage: Use each language's strengths</li> <li>Flexible deployment: Run anywhere needed</li> <li>Future-proof: Scale as requirements grow</li> </ul> <p>Key Insight</p> <p>We're not performance-obsessed, we're value-obsessed. We only add C++ when it actually solves a real problem.</p>"},{"location":"pybind11/best-practices/","title":"Best Practices","text":"<p>Building maintainable Python-C++ bindings requires following established patterns. Here are the rules that actually matter.</p>"},{"location":"pybind11/best-practices/#naming-conventions","title":"Naming Conventions","text":""},{"location":"pybind11/best-practices/#c-functions","title":"C++ Functions","text":"<pre><code>// Good: snake_case for functions\nauto conv2d(const std::vector&lt;float&gt;&amp; input) -&gt; std::vector&lt;float&gt;;\nauto gaussian_blur(const Image&amp; image, float sigma) -&gt; Image;\n\n// Good: PascalCase for classes\nclass ImageProcessor {\npublic:\n    void process_image(const Image&amp; input);\n};\n</code></pre>"},{"location":"pybind11/best-practices/#python-functions","title":"Python Functions","text":"<pre><code># Good: snake_case with suffixes\ndef conv2d_cpp(image, kernel):\n    \"\"\"C++ implementation.\"\"\"\n    pass\n\ndef conv2d_python(image, kernel):\n    \"\"\"Python implementation.\"\"\"\n    pass\n\ndef conv2d(image, kernel):\n    \"\"\"Smart wrapper that chooses implementation.\"\"\"\n    pass\n</code></pre>"},{"location":"pybind11/best-practices/#code-organization","title":"Code Organization","text":""},{"location":"pybind11/best-practices/#file-structure","title":"File Structure","text":"<pre><code>nextcv/\n\u251c\u2500\u2500 _cpp/src/\n\u2502   \u251c\u2500\u2500 core/           # Core functionality\n\u2502   \u251c\u2500\u2500 image/          # Image processing\n\u2502   \u251c\u2500\u2500 tracking/       # Tracking algorithms\n\u2502   \u2514\u2500\u2500 bindings/       # PyBind11 bindings\n\u251c\u2500\u2500 core/               # Python core modules\n\u251c\u2500\u2500 image/              # Python image modules\n\u2514\u2500\u2500 tracking/           # Python tracking modules\n</code></pre>"},{"location":"pybind11/best-practices/#binding-organization","title":"Binding Organization","text":"<pre><code>// Group related functions\nmodule.def(\"conv2d\", &amp;conv2d, \"Apply 2D convolution\");\nmodule.def(\"gaussian_blur\", &amp;gaussian_blur, \"Apply Gaussian blur\");\nmodule.def(\"edge_detection\", &amp;edge_detection, \"Detect edges\");\n</code></pre>"},{"location":"pybind11/best-practices/#error-handling","title":"Error Handling","text":""},{"location":"pybind11/best-practices/#input-validation","title":"Input Validation","text":"<pre><code>py::array_t&lt;float&gt; my_function(py::array_t&lt;float&gt; input) {\n    // Always validate inputs\n    if (input.ndim() != 2) {\n        throw std::runtime_error(\"Input must be 2D\");\n    }\n\n    if (!(input.flags() &amp; py::array::c_style)) {\n        throw std::runtime_error(\"Input must be C-contiguous\");\n    }\n\n    // Process data...\n}\n</code></pre>"},{"location":"pybind11/best-practices/#exception-safety","title":"Exception Safety","text":"<pre><code>// Use RAII for automatic cleanup\nclass ImageProcessor {\nprivate:\n    std::vector&lt;float&gt; data_;\n\npublic:\n    ImageProcessor(size_t size) : data_(size) {}\n    // Destructor automatically cleans up\n};\n</code></pre>"},{"location":"pybind11/best-practices/#memory-management","title":"Memory Management","text":""},{"location":"pybind11/best-practices/#efficient-array-handling","title":"Efficient Array Handling","text":"<pre><code>py::array_t&lt;float&gt; process_array(py::array_t&lt;float&gt; input) {\n    // Get buffer info once\n    py::buffer_info buf = input.request();\n    float* ptr = static_cast&lt;float*&gt;(buf.ptr);\n\n    // Process in-place when possible\n    for (size_t i = 0; i &lt; buf.size; ++i) {\n        ptr[i] = process_pixel(ptr[i]);\n    }\n\n    return input; // Return same array\n}\n</code></pre>"},{"location":"pybind11/best-practices/#avoid-unnecessary-copies","title":"Avoid Unnecessary Copies","text":"<pre><code>// Good: Pass by reference\nvoid process_image(const std::vector&lt;float&gt;&amp; input, std::vector&lt;float&gt;&amp; output);\n\n// Bad: Pass by value\nvoid process_image(std::vector&lt;float&gt; input, std::vector&lt;float&gt; output);\n</code></pre>"},{"location":"pybind11/best-practices/#performance-tips","title":"Performance Tips","text":""},{"location":"pybind11/best-practices/#use-c-contiguous-arrays","title":"Use C-Contiguous Arrays","text":"<pre><code>// Always check for C-contiguity\nif (!(input.flags() &amp; py::array::c_style)) {\n    throw std::runtime_error(\"Input must be C-contiguous\");\n}\n</code></pre>"},{"location":"pybind11/best-practices/#optimize-hot-paths","title":"Optimize Hot Paths","text":"<pre><code>// Use const references for large objects\nvoid process_large_data(const std::vector&lt;float&gt;&amp; data) {\n    // Process data...\n}\n</code></pre>"},{"location":"pybind11/best-practices/#profile-before-optimizing","title":"Profile Before Optimizing","text":"<pre><code>import cProfile\nimport nextcv as cvx\n\n# Profile your function\ncProfile.run('cvx.tracking.hungarian_algorithm(cost_matrix)')\n</code></pre>"},{"location":"pybind11/best-practices/#documentation","title":"Documentation","text":""},{"location":"pybind11/best-practices/#function-documentation","title":"Function Documentation","text":"<pre><code>/**\n * @brief Apply 2D convolution to an image\n * @param input Input image array\n * @param kernel Convolution kernel\n * @return Convolved image array\n */\npy::array_t&lt;float&gt; conv2d(py::array_t&lt;float&gt; input, py::array_t&lt;float&gt; kernel);\n</code></pre>"},{"location":"pybind11/best-practices/#python-docstrings","title":"Python Docstrings","text":"<pre><code>def conv2d(image, kernel):\n    \"\"\"\n    Apply 2D convolution to an image.\n\n    Args:\n        image: Input image array (H, W) or (H, W, C)\n        kernel: Convolution kernel (K, K)\n\n    Returns:\n        Convolved image array with same shape as input\n    \"\"\"\n    pass\n</code></pre>"},{"location":"pybind11/best-practices/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"pybind11/best-practices/#dont-over-optimize","title":"Don't Over-Optimize","text":"<ul> <li>Start with Python, optimize later</li> <li>Profile before optimizing</li> <li>Only optimize when it matters</li> </ul>"},{"location":"pybind11/best-practices/#dont-ignore-error-handling","title":"Don't Ignore Error Handling","text":"<ul> <li>Always validate inputs</li> <li>Handle edge cases</li> <li>Provide meaningful error messages</li> </ul>"},{"location":"pybind11/best-practices/#dont-skip-testing","title":"Don't Skip Testing","text":"<ul> <li>Test both implementations</li> <li>Test edge cases</li> <li>Test performance</li> </ul>"},{"location":"pybind11/best-practices/#pro-tips","title":"Pro Tips","text":"<ul> <li>Start simple - Get it working first, optimize later</li> <li>Use both implementations - Python for debugging, C++ for performance</li> <li>Profile everything - Measure before optimizing</li> <li>Document as you go - Don't leave it for later</li> <li>Test early and often - Catch issues before they become problems</li> </ul>"},{"location":"pybind11/best-practices/#next-steps","title":"Next Steps","text":"<ul> <li>Try the Simple Tutorial for hands-on practice</li> <li>Check Testing for robust testing strategies</li> <li>Explore Resources for advanced techniques</li> </ul>"},{"location":"pybind11/pybind11-basics/","title":"PyBind11 Basics","text":"<p>PyBind11 is a header-only library that exposes C++ code to Python. Think of it as a translator that handles type conversions, memory management, and NumPy integration.</p>"},{"location":"pybind11/pybind11-basics/#core-concepts","title":"Core Concepts","text":""},{"location":"pybind11/pybind11-basics/#module-definition","title":"Module Definition","text":"<pre><code>PYBIND11_MODULE(module_name, module) {\n    // Your bindings go here\n}\n</code></pre>"},{"location":"pybind11/pybind11-basics/#function-binding","title":"Function Binding","text":"<pre><code>// Simple function\nmodule.def(\"function_name\", &amp;cpp_function, \"Documentation\");\n\n// With arguments\nmodule.def(\"function_name\", &amp;cpp_function,\n           py::arg(\"arg1\"), py::arg(\"arg2\") = default_value,\n           \"Documentation\");\n</code></pre>"},{"location":"pybind11/pybind11-basics/#numpy-array-handling","title":"NumPy Array Handling","text":"<pre><code>py::array_t&lt;float&gt; my_function(py::array_t&lt;float&gt; input) {\n    py::buffer_info buf_info = input.request();\n    float* ptr = static_cast&lt;float*&gt;(buf_info.ptr);\n    // Process data...\n    return output;\n}\n</code></pre>"},{"location":"pybind11/pybind11-basics/#essential-types","title":"Essential Types","text":"C++ Type Python Type Notes <code>int</code> <code>int</code> Automatic conversion <code>float</code> <code>float</code> Automatic conversion <code>std::vector&lt;T&gt;</code> <code>list</code> Automatic conversion <code>py::array_t&lt;T&gt;</code> <code>numpy.ndarray</code> NumPy arrays"},{"location":"pybind11/pybind11-basics/#common-patterns","title":"Common Patterns","text":""},{"location":"pybind11/pybind11-basics/#input-validation","title":"Input Validation","text":"<pre><code>if (input.ndim() != 2) {\n    throw std::runtime_error(\"Input must be 2D\");\n}\n</code></pre>"},{"location":"pybind11/pybind11-basics/#memory-access","title":"Memory Access","text":"<pre><code>py::buffer_info buf = input.request();\nfloat* ptr = static_cast&lt;float*&gt;(buf.ptr);\n</code></pre>"},{"location":"pybind11/pybind11-basics/#return-arrays","title":"Return Arrays","text":"<pre><code>py::array_t&lt;float&gt; output({height, width});\npy::buffer_info out_buf = output.request();\nstd::memcpy(out_buf.ptr, result.data(), size * sizeof(float));\nreturn output;\n</code></pre>"},{"location":"pybind11/pybind11-basics/#pro-tips","title":"Pro Tips","text":"<ul> <li>Always validate inputs - Check dimensions, types, and contiguity</li> <li>Use C-contiguous arrays - Much faster for processing</li> <li>Handle exceptions properly - They become Python exceptions</li> <li>Document your functions - PyBind11 uses the docstrings</li> </ul>"},{"location":"pybind11/pybind11-basics/#next-steps","title":"Next Steps","text":"<ul> <li>Try the Simple Tutorial for hands-on practice</li> <li>Check Best Practices for advanced techniques</li> <li>Explore Testing for robust code</li> </ul>"},{"location":"pybind11/resources/","title":"Resources &amp; Learning Materials","text":"<p>Essential resources for mastering Python-C++ bindings and computer vision development.</p>"},{"location":"pybind11/resources/#core-documentation","title":"Core Documentation","text":""},{"location":"pybind11/resources/#pybind11","title":"PyBind11","text":"<ul> <li>PyBind11 Documentation - Complete reference and tutorial</li> <li>PyBind11 GitHub - Source code and examples</li> <li>PyBind11 Examples - Official examples</li> </ul>"},{"location":"pybind11/resources/#numpy","title":"NumPy","text":"<ul> <li>NumPy C API - NumPy array handling</li> <li>NumPy Array Interface - Understanding NumPy arrays</li> </ul>"},{"location":"pybind11/resources/#cmake","title":"CMake","text":"<ul> <li>CMake Documentation - Build system reference</li> <li>Modern CMake - Modern CMake techniques</li> </ul>"},{"location":"pybind11/resources/#learning-resources","title":"Learning Resources","text":""},{"location":"pybind11/resources/#python-c-integration","title":"Python-C++ Integration","text":"<ul> <li>Python C Extensions - Understanding Python extensions</li> <li>Cython Documentation - Alternative to PyBind11</li> </ul>"},{"location":"pybind11/resources/#c-best-practices","title":"C++ Best Practices","text":"<ul> <li>C++ Core Guidelines - Official C++ best practices</li> <li>C++ Reference - Complete C++ reference</li> </ul>"},{"location":"pybind11/resources/#computer-vision","title":"Computer Vision","text":"<ul> <li>OpenCV Documentation - Computer vision library</li> <li>scikit-image - Python image processing</li> </ul>"},{"location":"pybind11/resources/#performance--optimization","title":"Performance &amp; Optimization","text":""},{"location":"pybind11/resources/#c-performance","title":"C++ Performance","text":"<ul> <li>Intel Intrinsics Guide - SIMD optimization</li> <li>C++ Performance Tips - Performance best practices</li> </ul>"},{"location":"pybind11/resources/#python-performance","title":"Python Performance","text":"<ul> <li>Python Performance Tips - Python optimization</li> <li>NumPy Performance - NumPy optimization</li> </ul>"},{"location":"pybind11/resources/#tools--libraries","title":"Tools &amp; Libraries","text":""},{"location":"pybind11/resources/#development-tools","title":"Development Tools","text":"<ul> <li>Visual Studio Code - Great Python/C++ IDE</li> <li>CLion - Professional C++ IDE</li> <li>CMake Tools - VS Code CMake extension</li> </ul>"},{"location":"pybind11/resources/#testing--debugging","title":"Testing &amp; Debugging","text":"<ul> <li>pytest - Python testing framework</li> <li>Google Test - C++ testing framework</li> <li>Valgrind - Memory debugging tool</li> </ul>"},{"location":"pybind11/resources/#build-tools","title":"Build Tools","text":"<ul> <li>Ninja - Fast build system</li> <li>Conan - C++ package manager</li> <li>vcpkg - C++ library manager</li> </ul>"},{"location":"pybind11/resources/#community--support","title":"Community &amp; Support","text":""},{"location":"pybind11/resources/#forums--communities","title":"Forums &amp; Communities","text":"<ul> <li>PyBind11 Discussions - PyBind11 community</li> <li>Stack Overflow - PyBind11 questions</li> <li>Reddit r/cpp - C++ community</li> </ul>"},{"location":"pybind11/resources/#books","title":"Books","text":"<ul> <li>\"Effective C++\" by Scott Meyers - C++ best practices</li> <li>\"Python Cookbook\" by David Beazley - Advanced Python techniques</li> <li>\"Computer Vision: Algorithms and Applications\" by Richard Szeliski - CV fundamentals</li> </ul>"},{"location":"pybind11/resources/#pro-tips","title":"Pro Tips","text":"<ul> <li>Start with the basics - Master PyBind11 fundamentals before advanced techniques</li> <li>Read the source code - PyBind11 examples are excellent learning material</li> <li>Join the community - Ask questions and share knowledge</li> <li>Practice regularly - Build small projects to reinforce learning</li> <li>Profile everything - Measure before optimizing</li> </ul>"},{"location":"pybind11/resources/#next-steps","title":"Next Steps","text":"<ul> <li>Try the Simple Tutorial for hands-on practice</li> <li>Check Best Practices for advanced techniques</li> <li>Explore Testing for robust development</li> </ul>"},{"location":"pybind11/simple-tutorial/","title":"Simple PyBind11 Tutorial","text":"<p>Let's build something basic - a simple function that adds two numbers. This is the \"Hello World\" of PyBind11.</p>"},{"location":"pybind11/simple-tutorial/#what-were-building","title":"What We're Building","text":"<p>A C++ function that adds two integers, bound to Python. Nothing fancy, just the fundamentals.</p>"},{"location":"pybind11/simple-tutorial/#step-1-c-function","title":"Step 1: C++ Function","text":"<p>Create a simple header:</p> <pre><code>// nextcv/_cpp/src/core/add.hpp\n#pragma once\n\nint add(int a, int b);\n</code></pre> <p>Implement it:</p> <pre><code>// nextcv/_cpp/src/core/add.cpp\n#include \"add.hpp\"\n\nint add(int a, int b) {\n    return a + b;\n}\n</code></pre>"},{"location":"pybind11/simple-tutorial/#step-2-python-binding","title":"Step 2: Python Binding","text":"<p>Add to your bindings file:</p> <pre><code>// nextcv/_cpp/src/bindings/bindings.cpp\n#include &lt;pybind11/pybind11.h&gt;\n#include \"../core/add.hpp\"\n\nPYBIND11_MODULE(nextcv_py, module) {\n    module.def(\"add\", &amp;add, \"Add two integers\");\n}\n</code></pre>"},{"location":"pybind11/simple-tutorial/#step-3-use-it","title":"Step 3: Use It","text":"<pre><code>import nextcv as cvx\n\nresult = cvx.add(5, 3)  # Returns 8\nprint(result)\n</code></pre>"},{"location":"pybind11/simple-tutorial/#thats-it","title":"That's It!","text":"<p>You've just created your first PyBind11 binding. The C++ function is now available in Python with zero overhead.</p>"},{"location":"pybind11/simple-tutorial/#next-steps","title":"Next Steps","text":"<ul> <li>Try binding a function that takes NumPy arrays</li> <li>Add error handling</li> <li>Explore more complex data types</li> </ul> <p>Remember: Start simple, then add complexity as needed.</p>"},{"location":"pybind11/testing/","title":"Testing &amp; Debugging","text":"<p>Essential testing strategy for NextCV C++-Python bindings.</p>"},{"location":"pybind11/testing/#essential-tests","title":"Essential Tests","text":""},{"location":"pybind11/testing/#test-both-implementations","title":"Test Both Implementations","text":"<pre><code>import numpy as np\nimport nextcv.postprocessing as pp\n\ndef test_nms_implementations():\n    \"\"\"Test that C++ and Python NMS produce the same result.\"\"\"\n    bboxes = np.array([\n        [10, 10, 50, 50],   # Box 0\n        [15, 15, 55, 55],   # Box 1 (overlaps with 0)\n        [100, 100, 150, 150] # Box 2 (separate)\n    ], dtype=np.float32)\n\n    scores = np.array([0.9, 0.8, 0.7], dtype=np.float32)\n\n    # Compare implementations\n    result_cpp = pp.nms_cpp(bboxes, scores, 0.5)\n    result_py = pp.nms_np(bboxes, scores, 0.5)\n    np.testing.assert_array_equal(result_cpp, result_py)\n</code></pre>"},{"location":"pybind11/testing/#test-edge-cases","title":"Test Edge Cases","text":"<pre><code>def test_edge_cases():\n    \"\"\"Test empty and single inputs.\"\"\"\n    # Empty input\n    empty_bboxes = np.array([], dtype=np.float32).reshape(0, 4)\n    empty_scores = np.array([], dtype=np.float32)\n    result = pp.nms_np(empty_bboxes, empty_scores, 0.5)\n    assert len(result) == 0\n\n    # Single box\n    single_bbox = np.array([[10, 10, 50, 50]], dtype=np.float32)\n    single_score = np.array([0.9], dtype=np.float32)\n    result = pp.nms_np(single_bbox, single_score, 0.5)\n    assert len(result) == 1\n</code></pre>"},{"location":"pybind11/testing/#test-image-operations","title":"Test Image Operations","text":"<pre><code>import nextcv.image.ops as ops\n\ndef test_invert_function():\n    \"\"\"Test image inversion.\"\"\"\n    image = np.array([[[255, 0, 0], [0, 255, 0]]], dtype=np.uint8)\n    inverted = ops.invert(image)\n\n    assert inverted.shape == image.shape\n    assert inverted[0, 0, 0] == 0  # 255 -&gt; 0\n</code></pre>"},{"location":"pybind11/testing/#debugging-tips","title":"Debugging Tips","text":""},{"location":"pybind11/testing/#use-python-fallbacks","title":"Use Python Fallbacks","text":"<pre><code># Force Python implementation for debugging\npp.nms_cpp = None\nresult = pp.nms_np(bboxes, scores, 0.5)  # Uses Python only\n</code></pre>"},{"location":"pybind11/testing/#test-invalid-inputs","title":"Test Invalid Inputs","text":"<pre><code>import pytest\n\ndef test_invalid_inputs():\n    \"\"\"Test error handling.\"\"\"\n    bboxes = np.array([[10, 10, 50, 50]], dtype=np.float32)\n    scores = np.array([0.9], dtype=np.float32)\n\n    # Wrong number of scores\n    with pytest.raises(ValueError):\n        pp.nms_np(bboxes, scores[:0], 0.5)\n</code></pre>"},{"location":"pybind11/testing/#common-issues","title":"Common Issues","text":"<ul> <li>Memory Leaks - Use RAII in C++ and proper NumPy handling</li> <li>Type Mismatches - Validate <code>dtype</code> and <code>shape</code> before processing</li> <li>Performance Regression - Profile with <code>%timeit</code> in Jupyter</li> <li>Bounding Box Format - Always use (x1, y1, x2, y2) format</li> </ul>"},{"location":"pybind11/testing/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\npytest tests/\n\n# Run specific module\npytest tests/postprocessing/\n\n# Run specific test\npytest tests/postprocessing/test_boxes.py::test_nms_np\n</code></pre>"},{"location":"pybind11/testing/#pro-tips","title":"Pro Tips","text":"<ul> <li>Compare all implementations - C++, Python, and OpenCV</li> <li>Test edge cases - Empty boxes, single boxes, overlapping boxes</li> <li>Use Python fallbacks - Debug complex logic in Python first</li> <li>Profile performance - Ensure C++ actually helps</li> </ul>"},{"location":"pybind11/when-to-use-cpp/","title":"When to Use C++","text":"<p>Before you touch C++, ask yourself: do I really need it? C++ adds complexity, so use it only when it makes a meaningful impact.</p> <p>The TL;DR</p> <p>Only use C++ when you have a real performance bottleneck that can't be solved with existing Python tools.</p>"},{"location":"pybind11/when-to-use-cpp/#-the-decision-tree","title":"\ud83e\udde0 The Decision Tree","text":"Question 1: Existing Solutions?Question 2: Performance Critical?Question 3: Real Bottleneck?Question 4: C++ Advantage? <p>Does a good Python library already exist? \u2705 Yes \u2192 Use it, don't reinvent the wheel. \u274c No \u2192 Continue to Question 2.</p> <p>Is this operation actually slow in Python? \u274c No \u2192 Stick with Python (premature optimization \u2260 productivity). \u2705 Yes \u2192 Continue to Question 3.</p> <p>Is it a real production bottleneck? \u274c No \u2192 Python is fine (users won't notice). \u2705 Yes \u2192 Continue to Question 4.</p> <p>Would C++ optimizations (SIMD, memory layout) make a big difference? \u274c No \u2192 Try NumPy or Numba first. \u2705 Yes \u2192 \ud83d\ude80 Write it in C++.</p>"},{"location":"pybind11/when-to-use-cpp/#-good-use-cases","title":"\u2705 Good Use Cases","text":"<p>Real-World Examples</p> Non-Maximum Suppression (NMS)Hungarian AlgorithmLow-Level Hardware Access <ul> <li>Why: Tight inner loops over many bounding boxes \u2192 Python too slow.</li> <li>Evidence: NMS benchmarks show 5\u201310\u00d7 speedups with C++.</li> <li>Typical Use: Object detection post-processing.</li> </ul> <ul> <li>Why: Matching problem grows O(n\u00b3), so Python overhead hurts fast.</li> <li>Evidence: SciPy's linear_sum_assignment is implemented in C for this reason.</li> <li>Typical Use: Tracking and object assignment.</li> </ul> <ul> <li>Why: Direct hardware control needs low-level access that Python can't provide.</li> <li>Evidence: Libraries like WiringPi and pigpio are C-based for reliable timing.</li> <li>Typical Use: IMU sensors, GPIO control, I2C/SPI communication.</li> </ul>"},{"location":"pybind11/when-to-use-cpp/#-common-pitfalls","title":"\ud83d\udea9 Common Pitfalls","text":"<p>Watch Out For These</p> Pitfall Description Better Approach \ud83c\udfc3\u200d\u2642\ufe0f \"C++ is faster!\" Assuming C++ automatically means better performance - Profile with cProfile first- Get concrete performance numbers- Document real bottlenecks \ud83d\udd27 Reinventing the Wheel Writing C++ code for solved problems - Check SciPy/NumPy first- Use battle-tested implementations- Focus on actual gaps"},{"location":"pybind11/when-to-use-cpp/#-final-checklist","title":"\u2705 Final Checklist","text":"<p>Before You Start</p> <p>Use this checklist before diving into C++:</p> <ul> <li>[ ] No good Python library exists</li> <li>[ ] Profiling shows a clear bottleneck</li> <li>[ ] Production workload hits this bottleneck</li> <li>[ ] C++ will give meaningful gains</li> <li>[ ] Team can maintain the C++ code</li> </ul> <p>If you check all boxes \u2014 go for it. Otherwise, stay in Python land. \ud83d\udc0d</p>"},{"location":"reference/","title":"nextcv","text":""},{"location":"reference/#nextcv","title":"nextcv","text":"<p>NextCV: Computer Vision library with C++ and Python implementations.</p> <p>This package provides both high-performance C++ wrapped functions and pure Python implementations in functional modules.</p> Usage <p>import nextcv as cvx</p> MODULE DESCRIPTION <code>core</code> <p>NextCV Core module - Core functionality.</p> <code>image</code> <p>NextCV Image module - Image processing functionality.</p> <code>postprocessing</code> <p>NextCV Postprocessing module - Post-processing functionality.</p> FUNCTION DESCRIPTION <code>hello_python</code> <p>Python implementation of hello function.</p>"},{"location":"reference/#nextcv--c-wrapped-functions","title":"C++ wrapped functions","text":"<p>cvx.image.invert(image) cvx.postprocessing.nms_fast(boxes, 0.5)</p>"},{"location":"reference/#nextcv--python-implementations","title":"Python implementations","text":"<p>cvx.postprocessing.nms(boxes, 0.5) cvx.core.hello()</p>"},{"location":"reference/#nextcv.hello_python","title":"nextcv.hello_python","text":"<pre><code>hello_python() -&gt; str\n</code></pre> <p>Python implementation of hello function.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>nextcv</li> <li>_cpp</li> <li>core<ul> <li>hello</li> </ul> </li> <li>image<ul> <li>color</li> <li>compose</li> <li>geometry</li> <li>ops</li> </ul> </li> <li>postprocessing<ul> <li>boxes</li> </ul> </li> </ul>"},{"location":"reference/_cpp/","title":"_cpp","text":""},{"location":"reference/_cpp/#nextcv._cpp","title":"nextcv._cpp","text":"MODULE DESCRIPTION <code>nextcv_py</code>"},{"location":"reference/core/","title":"core","text":""},{"location":"reference/core/#nextcv.core","title":"nextcv.core","text":"<p>NextCV Core module - Core functionality.</p> MODULE DESCRIPTION <code>hello</code> <p>Python implementation of hello function.</p> FUNCTION DESCRIPTION <code>hello_python</code> <p>Python implementation of hello function.</p>"},{"location":"reference/core/#nextcv.core.hello_python","title":"nextcv.core.hello_python","text":"<pre><code>hello_python() -&gt; str\n</code></pre> <p>Python implementation of hello function.</p>"},{"location":"reference/core/hello/","title":"hello","text":""},{"location":"reference/core/hello/#nextcv.core.hello","title":"nextcv.core.hello","text":"<p>Python implementation of hello function.</p> FUNCTION DESCRIPTION <code>hello_python</code> <p>Python implementation of hello function.</p>"},{"location":"reference/core/hello/#nextcv.core.hello.hello_python","title":"nextcv.core.hello.hello_python","text":"<pre><code>hello_python() -&gt; str\n</code></pre> <p>Python implementation of hello function.</p>"},{"location":"reference/image/","title":"image","text":""},{"location":"reference/image/#nextcv.image","title":"nextcv.image","text":"<p>NextCV Image module - Image processing functionality.</p> MODULE DESCRIPTION <code>color</code> <p>Color and intensity transformations.</p> <code>compose</code> <p>Image composition utilities.</p> <code>geometry</code> <p>Geometric image transformations.</p> <code>ops</code> <p>Basic pixel-wise operations.</p>"},{"location":"reference/image/color/","title":"color","text":""},{"location":"reference/image/color/#nextcv.image.color","title":"nextcv.image.color","text":"<p>Color and intensity transformations.</p> <p>Functions here adjust image brightness, contrast, and color representation. Includes operations like: - Colorspace conversion (e.g., BGR \u2194 GRAY, HSV, LAB) - Channel split/merge and per-channel adjustments - Histogram equalization and CLAHE for local contrast enhancement - Gamma correction and other tone-mapping techniques</p>"},{"location":"reference/image/compose/","title":"compose","text":""},{"location":"reference/image/compose/#nextcv.image.compose","title":"nextcv.image.compose","text":"<p>Image composition utilities.</p> <p>Functions here combine two or more images into a single result. Includes operations like: - Simple overlays and alpha blending - Masked compositing - Pairwise stitching (left/right) - Multi-image panorama creation</p> <p>These functions typically perform geometric alignment, warping, and optional seam blending to produce seamless composites.</p>"},{"location":"reference/image/geometry/","title":"geometry","text":""},{"location":"reference/image/geometry/#nextcv.image.geometry","title":"nextcv.image.geometry","text":"<p>Geometric image transformations.</p> <p>Functions here modify image shape, size, or pixel layout. Includes operations like: - Resizing with interpolation - Rotation, translation, and affine transforms - Perspective warping and remapping - Flipping, cropping, and padding</p>"},{"location":"reference/image/ops/","title":"ops","text":""},{"location":"reference/image/ops/#nextcv.image.ops","title":"nextcv.image.ops","text":"<p>Basic pixel-wise operations.</p> <p>Functions here work independently on each pixel without considering neighbors. Includes operations like: - Inversion (negative images) - Arithmetic (add, subtract, multiply, divide) - Bitwise logic (AND, OR, XOR, NOT) - Thresholding and normalization</p>"},{"location":"reference/postprocessing/","title":"postprocessing","text":""},{"location":"reference/postprocessing/#nextcv.postprocessing","title":"nextcv.postprocessing","text":"<p>NextCV Postprocessing module - Post-processing functionality.</p> MODULE DESCRIPTION <code>boxes</code> <p>Bounding box postprocessing functions.</p> FUNCTION DESCRIPTION <code>nms_cv2</code> <p>Non-Maximum-Supression (NMS) using OpenCV's dnn.NMSBoxes().</p> <code>nms_np</code> <p>Non-Maximum-Supression (NMS) algorithm to remove overlapping bounding boxes.</p>"},{"location":"reference/postprocessing/#nextcv.postprocessing.nms_cv2","title":"nextcv.postprocessing.nms_cv2","text":"<pre><code>nms_cv2(\n    bboxes: NDArray, scores: NDArray, iou_thresh: float\n) -&gt; NDArray\n</code></pre> <p>Non-Maximum-Supression (NMS) using OpenCV's dnn.NMSBoxes().</p> PARAMETER DESCRIPTION <code>bboxes</code> <p>The bounding boxes as (top_left_x, top_left_y, bottom_right_x, bottom_right_y).</p> <p> TYPE: <code>NDArray</code> </p> <code>scores</code> <p>The confidence scores for each bounding box.</p> <p> TYPE: <code>NDArray</code> </p> <code>iou_thresh</code> <p>The threshold for intersection over union.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>NDArray</code> <p>The indices of the bounding boxes to keep.</p>"},{"location":"reference/postprocessing/#nextcv.postprocessing.nms_np","title":"nextcv.postprocessing.nms_np","text":"<pre><code>nms_np(\n    bboxes: NDArray, scores: NDArray, iou_thresh: float\n) -&gt; NDArray\n</code></pre> <p>Non-Maximum-Supression (NMS) algorithm to remove overlapping bounding boxes.</p> PARAMETER DESCRIPTION <code>bboxes</code> <p>The bounding boxes as (top_left_x, top_left_y, bottom_right_x, bottom_right_y).</p> <p> TYPE: <code>NDArray</code> </p> <code>scores</code> <p>The confidence scores for each bounding box.</p> <p> TYPE: <code>NDArray</code> </p> <code>iou_thresh</code> <p>The threshold for intersection over union.</p> <p> TYPE: <code>float</code> </p> <code>classes</code> <p>The class labels for each bounding box. if None, all boxes are treated as the same class (agnostic NMS).</p> <p> </p> RETURNS DESCRIPTION <code>NDArray</code> <p>The indices of the bounding boxes to keep.</p>"},{"location":"reference/postprocessing/boxes/","title":"boxes","text":""},{"location":"reference/postprocessing/boxes/#nextcv.postprocessing.boxes","title":"nextcv.postprocessing.boxes","text":"<p>Bounding box postprocessing functions.</p> FUNCTION DESCRIPTION <code>iou_np</code> <p>Calculate intersection over union of target box with all others.</p> <code>nms_cv2</code> <p>Non-Maximum-Supression (NMS) using OpenCV's dnn.NMSBoxes().</p> <code>nms_np</code> <p>Non-Maximum-Supression (NMS) algorithm to remove overlapping bounding boxes.</p>"},{"location":"reference/postprocessing/boxes/#nextcv.postprocessing.boxes.iou_np","title":"nextcv.postprocessing.boxes.iou_np","text":"<pre><code>iou_np(\n    target_box: NDArray,\n    boxes: NDArray,\n    target_area: NDArray,\n    areas: NDArray,\n    inclusive: bool = False,\n) -&gt; NDArray\n</code></pre> <p>Calculate intersection over union of target box with all others.</p> PARAMETER DESCRIPTION <code>target_box</code> <p>The bounding box as (top_left_x, top_left_y, bottom_right_x, bottom_right_y).</p> <p> TYPE: <code>NDArray</code> </p> <code>boxes</code> <p>The bounding boxes as (top_left_x, top_left_y, bottom_right_x, bottom_right_y).</p> <p> TYPE: <code>NDArray</code> </p> <code>target_area</code> <p>The area of the target box.</p> <p> TYPE: <code>NDArray</code> </p> <code>areas</code> <p>The areas of all boxes.</p> <p> TYPE: <code>NDArray</code> </p> <code>inclusive</code> <p>If True, uses (x2 - x1 + 1) * (y2 - y1 + 1) for area. Enable only for integer, pixel-indexed boxes (VOC/OpenCV style).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>NDArray</code> <p>The intersection over union of the target box with all others.</p>"},{"location":"reference/postprocessing/boxes/#nextcv.postprocessing.boxes.nms_cv2","title":"nextcv.postprocessing.boxes.nms_cv2","text":"<pre><code>nms_cv2(\n    bboxes: NDArray, scores: NDArray, iou_thresh: float\n) -&gt; NDArray\n</code></pre> <p>Non-Maximum-Supression (NMS) using OpenCV's dnn.NMSBoxes().</p> PARAMETER DESCRIPTION <code>bboxes</code> <p>The bounding boxes as (top_left_x, top_left_y, bottom_right_x, bottom_right_y).</p> <p> TYPE: <code>NDArray</code> </p> <code>scores</code> <p>The confidence scores for each bounding box.</p> <p> TYPE: <code>NDArray</code> </p> <code>iou_thresh</code> <p>The threshold for intersection over union.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>NDArray</code> <p>The indices of the bounding boxes to keep.</p>"},{"location":"reference/postprocessing/boxes/#nextcv.postprocessing.boxes.nms_np","title":"nextcv.postprocessing.boxes.nms_np","text":"<pre><code>nms_np(\n    bboxes: NDArray, scores: NDArray, iou_thresh: float\n) -&gt; NDArray\n</code></pre> <p>Non-Maximum-Supression (NMS) algorithm to remove overlapping bounding boxes.</p> PARAMETER DESCRIPTION <code>bboxes</code> <p>The bounding boxes as (top_left_x, top_left_y, bottom_right_x, bottom_right_y).</p> <p> TYPE: <code>NDArray</code> </p> <code>scores</code> <p>The confidence scores for each bounding box.</p> <p> TYPE: <code>NDArray</code> </p> <code>iou_thresh</code> <p>The threshold for intersection over union.</p> <p> TYPE: <code>float</code> </p> <code>classes</code> <p>The class labels for each bounding box. if None, all boxes are treated as the same class (agnostic NMS).</p> <p> </p> RETURNS DESCRIPTION <code>NDArray</code> <p>The indices of the bounding boxes to keep.</p>"}]}